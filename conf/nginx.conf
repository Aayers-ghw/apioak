# 设置NginxWoker运行用户及运行组
# user nginx nginx;
# 设置Nginx工作进程数量
worker_processes 2;
# 设置Nginx进程ID存储文件
pid logs/apioak.pid;

events {
    # 事件驱动模型
    use epoll;
    # 最大连接数
    worker_connections 1024;
}

http {
    # dns
    # resolver 127.0.0.11;
    # 文件扩展名与文件类型映射表
    include mime.types;
    # 设置默认返回响应内容类型
    default_type application/octet-stream;
    # 设置主日志文件输出格式
    log_format main '$remote_addr\t$http_x_forwarded_for\t$time_iso8601\t$scheme://$http_host\t$request\t$request_length\t'
    '$http_referer\t$http_user_agent\t$connection_requests\t$upstream_cache_status\t$status\t'
    '$request_time\t$upstream_response_time\t$bytes_sent\t$body_bytes_sent\t$server_name\t'
    '$upstream_addr\t$upstream_status\t$request_id\t';
    # 设置API项目日志文件输出格式
    log_format api '$remote_addr\t$http_x_forwarded_for\t$time_iso8601\t$scheme://$http_host\t$request\t$request_length\t'
    '$http_referer\t$http_user_agent\t$connection_requests\t$upstream_cache_status\t$status\t'
    '$request_time\t$upstream_response_time\t$bytes_sent\t$body_bytes_sent\t$server_name\t$project\t$route_path\t$hostname\t'
    '$upstream_addr\t$upstream_status\t$upstream_request\t$request_id\t$app_version\t$api_version\t$network\t$device\t$platform\t';
    # 定义访问日志输出
    access_log logs/access.log main;
    # 定义错误日志输出
    error_log logs/error.log;
    # 开启系统调用
    # off 硬盘 >> kernel buffer >> user buffer>> kernel socket buffer >> 协议栈
    # on 硬盘 >> kernel buffer (快速拷贝到kernelsocket buffer) >> 协议栈
    sendfile on;
    # 请求处理完成后保持TCP连接时间
    keepalive_timeout 65s;
    # 指定Nginx与后端fastcgi server连接超时时间
    fastcgi_connect_timeout 25s;
    # 指定Nginx向后端传送请求超时时间
    fastcgi_send_timeout 25s;
    # 指定Nginx接收后端fastcgi响应请求超时时间
    fastcgi_read_timeout 25s;
    # 指定Nginx读取fastcgi响应第一部分需要用多大的缓冲区
    fastcgi_buffer_size 256k;
    # 指定Nginx需要用多大的缓冲区缓冲fastcgi的应答请求
    fastcgi_buffers 4 512k;
    # 整个数据请求需要多大的缓存区
    fastcgi_busy_buffers_size 1024k;
    # 写入缓存文件使用多大的数据块
    fastcgi_temp_file_write_size 1024k;
    # 设置请求最大请求体大小,超出返回413
    client_max_body_size 8M;
    # 设置用于请求主体的缓冲区大小，如果主体超过缓冲区大小，则完整主体或其一部分将写入临时文件
    client_body_buffer_size 1M;
    # 开启Gzip压缩
    gzip on;
    # 设置允许压缩的页面最小字节数
    gzip_min_length 1k;
    # 设置gzip申请内存的大小，其作用是按块大小的倍数申请内存空间
    gzip_buffers 8 16k;
    # 用于识别HTTP协议的版本
    gzip_http_version 1.1;
    # 设置gzip压缩等级,等级越底压缩速度越快文件压缩比越小，反之速度越慢文件压缩比越大
    gzip_comp_level 3;
    # 设置需要压缩的MIME类型
    gzip_types text/plain application/x-javascript application/javascript text/css application/xml;
    # 和http头有关系，加个vary头，给代理服务器用的，有的浏览器支持压缩，有的不支持，所以避免浪费不支持的也压缩
    gzip_vary on;
    # 共享内存（项目秘钥缓存）
    lua_shared_dict sgin-auth 2m;
    # 共享内存（请求速度限制缓存）
    lua_shared_dict limit_req_store 100m;
    # 共享内存（请求连接数限制缓存）
    lua_shared_dict limit_conn_store 100m;
    # 共享内存（数据缓存）
    lua_shared_dict api_data 20m;
    # 共享内存（路由缓存）
    lua_shared_dict routes 20m;
    # 共享内存（项目缓存）
    lua_shared_dict projects 1m;
    # 共享内存（黑白名单缓存）
    lua_shared_dict waf 2m;
    # 共享内存（黑白名单缓存）
    lua_shared_dict jwt-auth 2m;
    # lua模块搜索路径（lua模块）
    lua_package_path  "$prefix/deps/share/lua/5.1/?.lua;$prefix/deps/share/lua/5.1/apioak/?.lua;$prefix/?.lua;/usr/share/lua/5.1/?.lua;/usr/local/lor/?.lua;;";
    # lua模块搜索路径（c模块）
    lua_package_cpath "$prefix/deps/lib64/lua/5.1/?.so;$prefix/deps/lib/lua/5.1/?.so;/usr/lib64/lua/5.1/?.so;;";
    # lua代码缓存（生产环境关闭）
    # lua_code_cache off;
    # 定义上游服务
    upstream api.com {
        # 服务节点
        server 0.0.0.1;
        # 应用层负载均衡
        balancer_by_lua_block {
            application.balancer()
        }
        # 指定Nginx每个worker连接后端的最大长连接数
        keepalive 1024;
    }
    # 设置代理缓存地址、目录文件缓存策略、分配内存大小
    proxy_cache_path /tmp/cache/nginx levels=1:2 keys_zone=api_cache:20m inactive=10h max_size=500m;
    # 初始化Lua框架配置加载相关插件
    init_by_lua_block {
        application = require "apioak.main"
        application.init()
    }
    # 初始化并调用全部插件Worker阶段工作
    init_worker_by_lua_block {
        application.init_worker()
    }

    server {
        # 监听端口配置
        listen 10080;
        # 开启SSL访问
        # listen 443 ssl;
        # 引入SSL配置
        # include ssl_params;
        # 设置访问日志路径
        access_log logs/api-access.log api;
        # 设置错误日志路径
        error_log logs/api-error.log;
        # 设置默认返回响应内容类型
        default_type application/json;
        # 设置默认后端服务器地址
        set $upstream_host $host;
        # 设置默认请求URI
        set $route_path $uri;
        # 设置默认项目前缀
        set $project 'api';
        # 设置默认移动端应用版本
        set $app_version '';
        # 设置内外网默认变量
        set $network '';
        # 设置默认请求的api版本
        set $api_version 'v1';
        # 设置默认用户设备型号存储变量
        set $device '';
        # 设置默认的请求平台
        set $platform 'web';
        # 用于判断是否缓存该接口响应（默认为1所有接口都不缓存）
        set $no_cache 1;
        # 用于判断客户端请求是否直接穿透到后端（默认为1所有请求都穿都到后端）改配置暂未启用
        set $is_pass_cache 1;
        # 设置默认HttpCode为200的才会缓存
        set $cache_code 200;
        # 设置默认后端请求地址
        set $upstream_request $request;

        location / {
            # 增加响应Header（请求ID）
            add_header X-Request-Id $request_id;
            # Rewrite阶段，执行转发、重定向、缓存等功能
            rewrite_by_lua_block {
                application.rewrite()
            }
            # Access阶段，执行IP准入、接口权限等功能
            access_by_lua_block {
                application.access()
            }
            # HeaderFilter阶段，响应头部过滤处理
            header_filter_by_lua_block {
                application.header_filter()
            }
            # BodyFilter阶段，响应体过滤处理
            body_filter_by_lua_block {
                application.body_filter()
            }
            # Log阶段，会话完成后本地异步完成日志记录
            log_by_lua_block {
                application.log()
            }
            # 设置隐藏Header头信息
            proxy_hide_header Set-Cookie;
            # 设置不缓存的Header头信息
            proxy_ignore_headers Expires Cache-Control Set-Cookie;
            # 使用哪个代理缓存的Key
            proxy_cache api_cache;
            # 设置代理缓存的请求方法
            proxy_cache_methods GET;
            # 设置代理缓存Key由哪些参数组成
            proxy_cache_key $request_uri$http_authorization;
            # 设置不同响应码的缓存时间
            proxy_cache_valid 10m;
            # 出现配置中出现的错误直接托底旧数据
            proxy_cache_use_stale error timeout updating http_500 http_502 http_503 http_504;
            # 缓存并发锁，当Nginx缓存没有命中的时候只有一个请求回源业务后端请求数据
            proxy_cache_lock on;
            # 设置不缓存，值只有两种0或非0，非0则不缓存
            proxy_no_cache $no_cache;
            # 增加响应Header（缓存状态）
            add_header X-Cache-PASS $upstream_cache_status;
            # 设置代理转发地址
            proxy_pass http://api.com;
            # 重新设置发往后端的请求头（Host地址）
            proxy_set_header Host $upstream_host;
            # 重新设置发往后端的请求头（真实IP地址）
            proxy_set_header X-Real-IP $remote_addr;
            # 重新设置发往后端的请求头（代理IP地址）
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            # 配置当上游返回的是转发请求时请求的代理服务器
            proxy_redirect off;
            # 服务容灾，当出现配置中的异常响应时Nginx会请求另一台上游服务器
            proxy_next_upstream error timeout http_404 http_500 http_504 http_502;
            # 请求传递到下一个服务器的可能尝试次数
            proxy_next_upstream_tries 5;
            # 重新设置发往后端的请求头（请求ID）
            proxy_set_header X-Request-Id $request_id;
        }

        location /api/ {
            # 动态更新获取共享缓存配置
            content_by_lua_file apioak/api/main.lua;
        }

        location = /favicon.ico {
            log_not_found off;
            access_log off;
            error_log off;
        }

        location /robots.txt {
            return 200 'User-agent: *\nDisallow: /';
        }
    }
}
